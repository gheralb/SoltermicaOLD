// Translated Modelica model generated by Dymola from Modelica model 
//  Soltermica.Acumuladores.Interacumuladores.Verificacion_02


// -----------------------------------------------------------------------------

// Initial Section
  prescribedVolumeFlow.m := 0.1;
  prescribedVolumeFlow1.m := 0.1;
  prescribedVolumeFlow.Q_flow := 0;
  prescribedVolumeFlow1.Q_flow := 0;
// -----------------------------------------------------------------------------

// Bound Parameter Section
  ambient.flowPort.medium.rho := ambient.medium.rho;
  ambient.flowPort.medium.cp := ambient.medium.cp;
  ambient.flowPort.medium.cv := ambient.medium.cv;
  ambient.flowPort.medium.lamda := ambient.medium.lamda;
  ambient.flowPort.medium.nue := ambient.medium.nue;
  ambient1.flowPort.medium.rho := ambient1.medium.rho;
  ambient1.flowPort.medium.cp := ambient1.medium.cp;
  ambient1.flowPort.medium.cv := ambient1.medium.cv;
  ambient1.flowPort.medium.lamda := ambient1.medium.lamda;
  ambient1.flowPort.medium.nue := ambient1.medium.nue;
  trapezoid.T_rising := trapezoid.rising;
  trapezoid.T_width := trapezoid.T_rising+trapezoid.width;
  trapezoid.T_falling := trapezoid.T_width+trapezoid.falling;
  prescribedVolumeFlow.flowPort_a.medium.rho := prescribedVolumeFlow.medium.rho;
  prescribedVolumeFlow.flowPort_a.medium.cp := prescribedVolumeFlow.medium.cp;
  prescribedVolumeFlow.flowPort_a.medium.cv := prescribedVolumeFlow.medium.cv;
  prescribedVolumeFlow.flowPort_a.medium.lamda := prescribedVolumeFlow.medium.lamda;
  prescribedVolumeFlow.flowPort_a.medium.nue := prescribedVolumeFlow.medium.nue;
  prescribedVolumeFlow.flowPort_b.medium.rho := prescribedVolumeFlow.medium.rho;
  prescribedVolumeFlow.flowPort_b.medium.cp := prescribedVolumeFlow.medium.cp;
  prescribedVolumeFlow.flowPort_b.medium.cv := prescribedVolumeFlow.medium.cv;
  prescribedVolumeFlow.flowPort_b.medium.lamda := prescribedVolumeFlow.medium.lamda;
  prescribedVolumeFlow.flowPort_b.medium.nue := prescribedVolumeFlow.medium.nue;
  ambient3.flowPort.medium.rho := ambient3.medium.rho;
  ambient3.flowPort.medium.cp := ambient3.medium.cp;
  ambient3.flowPort.medium.cv := ambient3.medium.cv;
  ambient3.flowPort.medium.lamda := ambient3.medium.lamda;
  ambient3.flowPort.medium.nue := ambient3.medium.nue;
  prescribedAmbient.flowPort.medium.rho := prescribedAmbient.medium.rho;
  prescribedAmbient.flowPort.medium.cp := prescribedAmbient.medium.cp;
  prescribedAmbient.flowPort.medium.cv := prescribedAmbient.medium.cv;
  prescribedAmbient.flowPort.medium.lamda := prescribedAmbient.medium.lamda;
  prescribedAmbient.flowPort.medium.nue := prescribedAmbient.medium.nue;
  prescribedVolumeFlow1.flowPort_a.medium.rho := prescribedVolumeFlow1.medium.rho;
  prescribedVolumeFlow1.flowPort_a.medium.cp := prescribedVolumeFlow1.medium.cp;
  prescribedVolumeFlow1.flowPort_a.medium.cv := prescribedVolumeFlow1.medium.cv;
  prescribedVolumeFlow1.flowPort_a.medium.lamda := prescribedVolumeFlow1.medium.lamda;
  prescribedVolumeFlow1.flowPort_a.medium.nue := prescribedVolumeFlow1.medium.nue;
  prescribedVolumeFlow1.flowPort_b.medium.rho := prescribedVolumeFlow1.medium.rho;
  prescribedVolumeFlow1.flowPort_b.medium.cp := prescribedVolumeFlow1.medium.cp;
  prescribedVolumeFlow1.flowPort_b.medium.cv := prescribedVolumeFlow1.medium.cv;
  prescribedVolumeFlow1.flowPort_b.medium.lamda := prescribedVolumeFlow1.medium.lamda;
  prescribedVolumeFlow1.flowPort_b.medium.nue := prescribedVolumeFlow1.medium.nue;
  trapezoid1.T_rising := trapezoid1.rising;
  trapezoid1.T_width := trapezoid1.T_rising+trapezoid1.width;
  trapezoid1.T_falling := trapezoid1.T_width+trapezoid1.falling;
  interacumuladorSerpentin.flowPort_a_dep.medium.rho := interacumuladorSerpentin.medium_dep.rho;
  interacumuladorSerpentin.flowPort_a_dep.medium.cp := interacumuladorSerpentin.medium_dep.cp;
  interacumuladorSerpentin.flowPort_a_dep.medium.cv := interacumuladorSerpentin.medium_dep.cv;
  interacumuladorSerpentin.flowPort_a_dep.medium.lamda := interacumuladorSerpentin.medium_dep.lamda;
  interacumuladorSerpentin.flowPort_a_dep.medium.nue := interacumuladorSerpentin.medium_dep.nue;
  interacumuladorSerpentin.flowPort_b_dep.medium.rho := interacumuladorSerpentin.medium_dep.rho;
  interacumuladorSerpentin.flowPort_b_dep.medium.cp := interacumuladorSerpentin.medium_dep.cp;
  interacumuladorSerpentin.flowPort_b_dep.medium.cv := interacumuladorSerpentin.medium_dep.cv;
  interacumuladorSerpentin.flowPort_b_dep.medium.lamda := interacumuladorSerpentin.medium_dep.lamda;
  interacumuladorSerpentin.flowPort_b_dep.medium.nue := interacumuladorSerpentin.medium_dep.nue;
  interacumuladorSerpentin.flowPort_a_int.medium.rho := interacumuladorSerpentin.medium_int.rho;
  interacumuladorSerpentin.flowPort_a_int.medium.cp := interacumuladorSerpentin.medium_int.cp;
  interacumuladorSerpentin.flowPort_a_int.medium.cv := interacumuladorSerpentin.medium_int.cv;
  interacumuladorSerpentin.flowPort_a_int.medium.lamda := interacumuladorSerpentin.medium_int.lamda;
  interacumuladorSerpentin.flowPort_a_int.medium.nue := interacumuladorSerpentin.medium_int.nue;
  interacumuladorSerpentin.flowPort_b_int.medium.rho := interacumuladorSerpentin.medium_int.rho;
  interacumuladorSerpentin.flowPort_b_int.medium.cp := interacumuladorSerpentin.medium_int.cp;
  interacumuladorSerpentin.flowPort_b_int.medium.cv := interacumuladorSerpentin.medium_int.cv;
  interacumuladorSerpentin.flowPort_b_int.medium.lamda := interacumuladorSerpentin.medium_int.lamda;
  interacumuladorSerpentin.flowPort_b_int.medium.nue := interacumuladorSerpentin.medium_int.nue;
  ambient.h := ambient.medium.cp*ambient.T_Ambient;
  ambient1.h := ambient1.medium.cp*ambient1.T_Ambient;
  ambient3.h := ambient3.medium.cp*ambient3.T_Ambient;
// -----------------------------------------------------------------------------

// Initial Section
  trapezoid.T0 := trapezoid.startTime;
  trapezoid.counter := trapezoid.nperiod;
  trapezoid.counter2 := trapezoid.nperiod;
  trapezoid1.T0 := trapezoid1.startTime;
  trapezoid1.counter := trapezoid1.nperiod;
  trapezoid1.counter2 := trapezoid1.nperiod;
  prescribedVolumeFlow.T := prescribedVolumeFlow.T0;
  prescribedVolumeFlow1.T := prescribedVolumeFlow1.T0;
  trapezoid.T0_.start := trapezoid.T0;
  trapezoid.counter2_.start := trapezoid.counter2;
  trapezoid.counter_.start := trapezoid.counter;
  trapezoid1.T0_.start := trapezoid1.T0;
  trapezoid1.counter2_.start := trapezoid1.counter2;
  trapezoid1.counter_.start := trapezoid1.counter;
  interacumuladorSerpentin.T_dep := interacumuladorSerpentin.T0;
  prescribedVolumeFlow.T := prescribedVolumeFlow.T0;
  trapezoid.counter2_.start := trapezoid.nperiod;
  trapezoid.counter2 := trapezoid.counter2_.start;
  interacumuladorSerpentin.T_in_AF := interacumuladorSerpentin.T_dep;
  prescribedVolumeFlow.h := prescribedVolumeFlow.medium.cp*prescribedVolumeFlow.T;

  // Nonlinear system of equations
    // It depends on the following parameters: 
    //   interacumuladorSerpentin.medium_dep.cp
    // It depends on the following timevarying variables: 
    //   interacumuladorSerpentin.T_dep
    //   interacumuladorSerpentin.T_in_AF
    //   prescribedVolumeFlow.h
    // Unknowns[2]: 
    //   prescribedVolumeFlow.flowPort_b.h(start = 0)
    //   interacumuladorSerpentin.flowPort_a_dep.m_flow(start = 0)
  algorithm // Torn part
    interacumuladorSerpentin.flowPort_a_dep.H_flow := (if semiLinearCondition(
      noEvent(interacumuladorSerpentin.flowPort_a_dep.m_flow >= 0)) then 
      prescribedVolumeFlow.h*interacumuladorSerpentin.flowPort_a_dep.m_flow
       else prescribedVolumeFlow.flowPort_b.h*interacumuladorSerpentin.flowPort_a_dep.m_flow);

  equation // Residual equations
    0 = interacumuladorSerpentin.T_in_AF-(if noEvent(interacumuladorSerpentin.flowPort_a_dep.m_flow
       > 0) then prescribedVolumeFlow.flowPort_b.h/interacumuladorSerpentin.medium_dep.cp
       else interacumuladorSerpentin.T_dep);
    0 = interacumuladorSerpentin.flowPort_a_dep.H_flow-(if noEvent(
      interacumuladorSerpentin.flowPort_a_dep.m_flow > 0) then interacumuladorSerpentin.flowPort_a_dep.m_flow
      *interacumuladorSerpentin.medium_dep.cp*interacumuladorSerpentin.T_in_AF
       else 0);
  // Analytic Jacobian was produced, but it is not listed here.
  // To have it listed, set
  //   Advanced.OutputModelicaCodeWithJacobians = true
  // before translation. May give much output,
  // because common subexpression elimination is not activated.
  // End of nonlinear system of equations


  prescribedVolumeFlow.V_flow := interacumuladorSerpentin.flowPort_a_dep.m_flow/
    prescribedVolumeFlow.medium.rho;

  // Nonlinear system of equations
    // It depends on the following parameters: 
    //   trapezoid.T_falling
    //   trapezoid.T_rising
    //   trapezoid.T_width
    //   trapezoid.amplitude
    //   trapezoid.offset
    //   trapezoid.startTime
    // It depends on the following timevarying variables: 
    //   prescribedVolumeFlow.V_flow
    //   time
    //   trapezoid.counter2
    // Unknowns[1]: 
    //   trapezoid.T0(start = trapezoid.startTime)

  equation // Residual equations
    0 = prescribedVolumeFlow.V_flow-(trapezoid.offset+(if time < 
      trapezoid.startTime or trapezoid.counter2 == 0 or time >= trapezoid.T0+
      trapezoid.T_falling then 0 else (if time < trapezoid.T0+trapezoid.T_rising
       then (time-trapezoid.T0)*trapezoid.amplitude/trapezoid.T_rising else (if 
      time < trapezoid.T0+trapezoid.T_width then trapezoid.amplitude else (
      trapezoid.T0+trapezoid.T_falling-time)*trapezoid.amplitude/(
      trapezoid.T_falling-trapezoid.T_width)))));
  // Analytic Jacobian was produced, but it is not listed here.
  // To have it listed, set
  //   Advanced.OutputModelicaCodeWithJacobians = true
  // before translation. May give much output,
  // because common subexpression elimination is not activated.
  // End of nonlinear system of equations

  interacumuladorSerpentin.T_int := interacumuladorSerpentin.T0;
  prescribedVolumeFlow1.T := prescribedVolumeFlow1.T0;
  trapezoid1.counter2_.start := trapezoid1.nperiod;
  trapezoid1.counter2 := trapezoid1.counter2_.start;
  interacumuladorSerpentin.T_in_int := interacumuladorSerpentin.T_int;
  prescribedVolumeFlow1.h := prescribedVolumeFlow1.medium.cp*prescribedVolumeFlow1.T;

  // Nonlinear system of equations
    // It depends on the following parameters: 
    //   interacumuladorSerpentin.medium_int.cp
    // It depends on the following timevarying variables: 
    //   interacumuladorSerpentin.T_in_int
    //   interacumuladorSerpentin.T_int
    //   prescribedVolumeFlow1.h
    // Unknowns[2]: 
    //   prescribedVolumeFlow1.flowPort_b.h(start = 0)
    //   interacumuladorSerpentin.flowPort_a_int.m_flow(start = 0)
  algorithm // Torn part
    interacumuladorSerpentin.flowPort_a_int.H_flow := (if semiLinearCondition(
      noEvent(interacumuladorSerpentin.flowPort_a_int.m_flow >= 0)) then 
      prescribedVolumeFlow1.h*interacumuladorSerpentin.flowPort_a_int.m_flow
       else prescribedVolumeFlow1.flowPort_b.h*interacumuladorSerpentin.flowPort_a_int.m_flow);

  equation // Residual equations
    0 = interacumuladorSerpentin.T_in_int-(if noEvent(interacumuladorSerpentin.flowPort_a_int.m_flow
       > 0) then prescribedVolumeFlow1.flowPort_b.h/interacumuladorSerpentin.medium_int.cp
       else interacumuladorSerpentin.T_int);
    0 = interacumuladorSerpentin.flowPort_a_int.H_flow-(if noEvent(
      interacumuladorSerpentin.flowPort_a_int.m_flow > 0) then interacumuladorSerpentin.flowPort_a_int.m_flow
      *interacumuladorSerpentin.medium_int.cp*interacumuladorSerpentin.T_in_int
       else 0);
  // Analytic Jacobian was produced, but it is not listed here.
  // To have it listed, set
  //   Advanced.OutputModelicaCodeWithJacobians = true
  // before translation. May give much output,
  // because common subexpression elimination is not activated.
  // End of nonlinear system of equations


  prescribedVolumeFlow1.V_flow := interacumuladorSerpentin.flowPort_a_int.m_flow
    /prescribedVolumeFlow1.medium.rho;

  // Nonlinear system of equations
    // It depends on the following parameters: 
    //   trapezoid1.T_falling
    //   trapezoid1.T_rising
    //   trapezoid1.T_width
    //   trapezoid1.amplitude
    //   trapezoid1.offset
    //   trapezoid1.startTime
    // It depends on the following timevarying variables: 
    //   prescribedVolumeFlow1.V_flow
    //   time
    //   trapezoid1.counter2
    // Unknowns[1]: 
    //   trapezoid1.T0(start = trapezoid1.startTime)

  equation // Residual equations
    0 = prescribedVolumeFlow1.V_flow-(trapezoid1.offset+(if time < 
      trapezoid1.startTime or trapezoid1.counter2 == 0 or time >= trapezoid1.T0+
      trapezoid1.T_falling then 0 else (if time < trapezoid1.T0+trapezoid1.T_rising
       then (time-trapezoid1.T0)*trapezoid1.amplitude/trapezoid1.T_rising else (
      if time < trapezoid1.T0+trapezoid1.T_width then trapezoid1.amplitude else 
      (trapezoid1.T0+trapezoid1.T_falling-time)*trapezoid1.amplitude/(
      trapezoid1.T_falling-trapezoid1.T_width)))));
  // Analytic Jacobian was produced, but it is not listed here.
  // To have it listed, set
  //   Advanced.OutputModelicaCodeWithJacobians = true
  // before translation. May give much output,
  // because common subexpression elimination is not activated.
  // End of nonlinear system of equations

  trapezoid.T0_.start := trapezoid.T0;
  trapezoid1.T0_.start := trapezoid1.T0;
  trapezoid.counter_.start := trapezoid.nperiod;
  trapezoid.counter := trapezoid.counter_.start;
  trapezoid1.counter_.start := trapezoid1.nperiod;
  trapezoid1.counter := trapezoid1.counter_.start;
  assert(abs(prescribedVolumeFlow.flowPort_a.medium.cp-ambient.flowPort.medium.cp)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow.flowPort_a.medium.cv-ambient.flowPort.medium.cv)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow.flowPort_a.medium.lamda-ambient.flowPort.medium.lamda)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow.flowPort_a.medium.nue-ambient.flowPort.medium.nue)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow.flowPort_a.medium.rho-ambient.flowPort.medium.rho)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(interacumuladorSerpentin.flowPort_b_dep.medium.cp-ambient1.flowPort.medium.cp)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(interacumuladorSerpentin.flowPort_b_dep.medium.cv-ambient1.flowPort.medium.cv)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(interacumuladorSerpentin.flowPort_b_dep.medium.lamda-
    ambient1.flowPort.medium.lamda) <= 0, "Parameters in connected connectors must be equal");
  assert(abs(interacumuladorSerpentin.flowPort_b_dep.medium.nue-ambient1.flowPort.medium.nue)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(interacumuladorSerpentin.flowPort_b_dep.medium.rho-ambient1.flowPort.medium.rho)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(interacumuladorSerpentin.flowPort_b_int.medium.cp-ambient3.flowPort.medium.cp)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(interacumuladorSerpentin.flowPort_b_int.medium.cv-ambient3.flowPort.medium.cv)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(interacumuladorSerpentin.flowPort_b_int.medium.lamda-
    ambient3.flowPort.medium.lamda) <= 0, "Parameters in connected connectors must be equal");
  assert(abs(interacumuladorSerpentin.flowPort_b_int.medium.nue-ambient3.flowPort.medium.nue)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(interacumuladorSerpentin.flowPort_b_int.medium.rho-ambient3.flowPort.medium.rho)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow.flowPort_b.medium.cp-interacumuladorSerpentin.flowPort_a_dep.medium.cp)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow.flowPort_b.medium.cv-interacumuladorSerpentin.flowPort_a_dep.medium.cv)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow.flowPort_b.medium.lamda-interacumuladorSerpentin.flowPort_a_dep.medium.lamda)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow.flowPort_b.medium.nue-interacumuladorSerpentin.flowPort_a_dep.medium.nue)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow.flowPort_b.medium.rho-interacumuladorSerpentin.flowPort_a_dep.medium.rho)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow1.flowPort_b.medium.cp-interacumuladorSerpentin.flowPort_a_int.medium.cp)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow1.flowPort_b.medium.cv-interacumuladorSerpentin.flowPort_a_int.medium.cv)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow1.flowPort_b.medium.lamda-interacumuladorSerpentin.flowPort_a_int.medium.lamda)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow1.flowPort_b.medium.nue-interacumuladorSerpentin.flowPort_a_int.medium.nue)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow1.flowPort_b.medium.rho-interacumuladorSerpentin.flowPort_a_int.medium.rho)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow1.flowPort_a.medium.cp-prescribedAmbient.flowPort.medium.cp)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow1.flowPort_a.medium.cv-prescribedAmbient.flowPort.medium.cv)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow1.flowPort_a.medium.lamda-prescribedAmbient.flowPort.medium.lamda)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow1.flowPort_a.medium.nue-prescribedAmbient.flowPort.medium.nue)
     <= 0, "Parameters in connected connectors must be equal");
  assert(abs(prescribedVolumeFlow1.flowPort_a.medium.rho-prescribedAmbient.flowPort.medium.rho)
     <= 0, "Parameters in connected connectors must be equal");


// -----------------------------------------------------------------------------

// Dynamics Section
  when pre(trapezoid.counter2) <> 0 and sample(trapezoid.startTime, 
    trapezoid.period) then
    trapezoid.counter2 := pre(trapezoid.counter);
  end when;
  when pre(trapezoid.counter2) <> 0 and sample(trapezoid.startTime, 
    trapezoid.period) then
    trapezoid.T0 := time;
  end when;
  prescribedVolumeFlow.V_flow := trapezoid.offset+(if time < trapezoid.startTime
     or trapezoid.counter2 == 0 or time >= trapezoid.T0+trapezoid.T_falling
     then 0 else (if time < trapezoid.T0+trapezoid.T_rising then (time-
    trapezoid.T0)*trapezoid.amplitude/trapezoid.T_rising else (if time < 
    trapezoid.T0+trapezoid.T_width then trapezoid.amplitude else (trapezoid.T0+
    trapezoid.T_falling-time)*trapezoid.amplitude/(trapezoid.T_falling-
    trapezoid.T_width))));

  // Linear system of equations
    // Symbolic solution
      /*  Original equation
       -interacumuladorSerpentin.flowPort_a_dep.m_flow/prescribedVolumeFlow.medium.rho
         =  -prescribedVolumeFlow.V_flow;
      */
      interacumuladorSerpentin.flowPort_a_dep.m_flow := prescribedVolumeFlow.V_flow
        *prescribedVolumeFlow.medium.rho;

    // Torn part
  // End of linear system of equations
  prescribedVolumeFlow.h := prescribedVolumeFlow.medium.cp*prescribedVolumeFlow.T;
  prescribedVolumeFlow.flowPort_a.H_flow := (if semiLinearCondition(noEvent(
    interacumuladorSerpentin.flowPort_a_dep.m_flow >= 0)) then ambient.h*
    interacumuladorSerpentin.flowPort_a_dep.m_flow else prescribedVolumeFlow.h*
    interacumuladorSerpentin.flowPort_a_dep.m_flow);

  // Linear system of equations
    // Symbolic solution
      /*  Original equation
      interacumuladorSerpentin.flowPort_a_dep.H_flow = (if noEvent(
        interacumuladorSerpentin.flowPort_a_dep.m_flow > 0) then 
        interacumuladorSerpentin.flowPort_a_dep.m_flow*interacumuladorSerpentin.medium_dep.cp
        *interacumuladorSerpentin.T_in_AF else 0);
      */
      prescribedVolumeFlow.flowPort_b.h := ((if noEvent(interacumuladorSerpentin.flowPort_a_dep.m_flow
         > 0) then interacumuladorSerpentin.flowPort_a_dep.m_flow*
        interacumuladorSerpentin.medium_dep.cp else 0)*(if noEvent(
        interacumuladorSerpentin.flowPort_a_dep.m_flow > 0) then 0 else 
        interacumuladorSerpentin.T_dep)-(if semiLinearCondition(noEvent(
        interacumuladorSerpentin.flowPort_a_dep.m_flow >= 0)) then 
        prescribedVolumeFlow.h*interacumuladorSerpentin.flowPort_a_dep.m_flow
         else 0))/((if semiLinearCondition(noEvent(interacumuladorSerpentin.flowPort_a_dep.m_flow
         >= 0)) then 0 else interacumuladorSerpentin.flowPort_a_dep.m_flow)-(if 
        noEvent(interacumuladorSerpentin.flowPort_a_dep.m_flow > 0) then 
        interacumuladorSerpentin.flowPort_a_dep.m_flow*interacumuladorSerpentin.medium_dep.cp
         else 0)*(if noEvent(interacumuladorSerpentin.flowPort_a_dep.m_flow > 0)
         then 1/interacumuladorSerpentin.medium_dep.cp else 0));

    // Torn part
      interacumuladorSerpentin.T_in_AF := (if noEvent(interacumuladorSerpentin.flowPort_a_dep.m_flow
         > 0) then prescribedVolumeFlow.flowPort_b.h/interacumuladorSerpentin.medium_dep.cp
         else interacumuladorSerpentin.T_dep);
      interacumuladorSerpentin.flowPort_a_dep.H_flow := (if semiLinearCondition(
        noEvent(interacumuladorSerpentin.flowPort_a_dep.m_flow >= 0)) then 
        prescribedVolumeFlow.h*interacumuladorSerpentin.flowPort_a_dep.m_flow
         else prescribedVolumeFlow.flowPort_b.h*interacumuladorSerpentin.flowPort_a_dep.m_flow);
  // End of linear system of equations


  // Linear system of equations
    // Symbolic solution
      /*  Original equation
      (-0.1)*prescribedVolumeFlow.medium.cv*der(prescribedVolumeFlow.T) = 
        interacumuladorSerpentin.flowPort_a_dep.H_flow-prescribedVolumeFlow.flowPort_a.H_flow;
      */
      der(prescribedVolumeFlow.T) := (interacumuladorSerpentin.flowPort_a_dep.H_flow
        -prescribedVolumeFlow.flowPort_a.H_flow)/((-0.1)*prescribedVolumeFlow.medium.cv);

    // Torn part
  // End of linear system of equations
  interacumuladorSerpentin.flowPort_b_dep.H_flow := (if noEvent( -
    interacumuladorSerpentin.flowPort_a_dep.m_flow < 0) then  -interacumuladorSerpentin.flowPort_a_dep.m_flow
    *interacumuladorSerpentin.medium_dep.cp*interacumuladorSerpentin.T_dep else 0);
  when pre(trapezoid1.counter2) <> 0 and sample(trapezoid1.startTime, 
    trapezoid1.period) then
    trapezoid1.counter2 := pre(trapezoid1.counter);
  end when;
  when pre(trapezoid1.counter2) <> 0 and sample(trapezoid1.startTime, 
    trapezoid1.period) then
    trapezoid1.T0 := time;
  end when;
  prescribedVolumeFlow1.V_flow := trapezoid1.offset+(if time < trapezoid1.startTime
     or trapezoid1.counter2 == 0 or time >= trapezoid1.T0+trapezoid1.T_falling
     then 0 else (if time < trapezoid1.T0+trapezoid1.T_rising then (time-
    trapezoid1.T0)*trapezoid1.amplitude/trapezoid1.T_rising else (if time < 
    trapezoid1.T0+trapezoid1.T_width then trapezoid1.amplitude else (
    trapezoid1.T0+trapezoid1.T_falling-time)*trapezoid1.amplitude/(
    trapezoid1.T_falling-trapezoid1.T_width))));

  // Linear system of equations
    // Symbolic solution
      /*  Original equation
       -interacumuladorSerpentin.flowPort_a_int.m_flow/prescribedVolumeFlow1.medium.rho
         =  -prescribedVolumeFlow1.V_flow;
      */
      interacumuladorSerpentin.flowPort_a_int.m_flow := prescribedVolumeFlow1.V_flow
        *prescribedVolumeFlow1.medium.rho;

    // Torn part
  // End of linear system of equations
  prescribedVolumeFlow1.h := prescribedVolumeFlow1.medium.cp*prescribedVolumeFlow1.T;

  // Linear system of equations
    // Symbolic solution
      /*  Original equation
      interacumuladorSerpentin.flowPort_a_int.H_flow = (if noEvent(
        interacumuladorSerpentin.flowPort_a_int.m_flow > 0) then 
        interacumuladorSerpentin.flowPort_a_int.m_flow*interacumuladorSerpentin.medium_int.cp
        *interacumuladorSerpentin.T_in_int else 0);
      */
      prescribedVolumeFlow1.flowPort_b.h := ((if noEvent(interacumuladorSerpentin.flowPort_a_int.m_flow
         > 0) then interacumuladorSerpentin.flowPort_a_int.m_flow*
        interacumuladorSerpentin.medium_int.cp else 0)*(if noEvent(
        interacumuladorSerpentin.flowPort_a_int.m_flow > 0) then 0 else 
        interacumuladorSerpentin.T_int)-(if semiLinearCondition(noEvent(
        interacumuladorSerpentin.flowPort_a_int.m_flow >= 0)) then 
        prescribedVolumeFlow1.h*interacumuladorSerpentin.flowPort_a_int.m_flow
         else 0))/((if semiLinearCondition(noEvent(interacumuladorSerpentin.flowPort_a_int.m_flow
         >= 0)) then 0 else interacumuladorSerpentin.flowPort_a_int.m_flow)-(if 
        noEvent(interacumuladorSerpentin.flowPort_a_int.m_flow > 0) then 
        interacumuladorSerpentin.flowPort_a_int.m_flow*interacumuladorSerpentin.medium_int.cp
         else 0)*(if noEvent(interacumuladorSerpentin.flowPort_a_int.m_flow > 0)
         then 1/interacumuladorSerpentin.medium_int.cp else 0));

    // Torn part
      interacumuladorSerpentin.flowPort_a_int.H_flow := (if semiLinearCondition(
        noEvent(interacumuladorSerpentin.flowPort_a_int.m_flow >= 0)) then 
        prescribedVolumeFlow1.h*interacumuladorSerpentin.flowPort_a_int.m_flow
         else prescribedVolumeFlow1.flowPort_b.h*interacumuladorSerpentin.flowPort_a_int.m_flow);
      interacumuladorSerpentin.T_in_int := (if noEvent(interacumuladorSerpentin.flowPort_a_int.m_flow
         > 0) then prescribedVolumeFlow1.flowPort_b.h/interacumuladorSerpentin.medium_int.cp
         else interacumuladorSerpentin.T_int);
  // End of linear system of equations

  interacumuladorSerpentin.DeltaT := 0.5*(interacumuladorSerpentin.T_in_int+
    interacumuladorSerpentin.T_int)-interacumuladorSerpentin.T_dep;
  interacumuladorSerpentin.Q_int_dep := interacumuladorSerpentin.esp.U_int*
    interacumuladorSerpentin.esp.A_int*interacumuladorSerpentin.DeltaT;

  // Linear system of equations
    // Symbolic solution
      /*  Original equation
       -interacumuladorSerpentin.esp.V_dep*interacumuladorSerpentin.medium_dep.rho
        *interacumuladorSerpentin.medium_dep.cp*der(interacumuladorSerpentin.T_dep)
         =  -(interacumuladorSerpentin.flowPort_a_dep.H_flow+interacumuladorSerpentin.flowPort_b_dep.H_flow
        +interacumuladorSerpentin.Q_int_dep);
      */
      der(interacumuladorSerpentin.T_dep) := (interacumuladorSerpentin.flowPort_a_dep.H_flow
        +interacumuladorSerpentin.flowPort_b_dep.H_flow+interacumuladorSerpentin.Q_int_dep)
        /(interacumuladorSerpentin.esp.V_dep*interacumuladorSerpentin.medium_dep.rho
        *interacumuladorSerpentin.medium_dep.cp);

    // Torn part
  // End of linear system of equations
  interacumuladorSerpentin.flowPort_b_int.H_flow := (if noEvent( -
    interacumuladorSerpentin.flowPort_a_int.m_flow < 0) then  -interacumuladorSerpentin.flowPort_a_int.m_flow
    *interacumuladorSerpentin.medium_int.cp*interacumuladorSerpentin.T_int else 0);

  // Linear system of equations
    // Symbolic solution
      /*  Original equation
       -interacumuladorSerpentin.esp.V_int*interacumuladorSerpentin.medium_int.rho
        *interacumuladorSerpentin.medium_int.cp*der(interacumuladorSerpentin.T_int)
         = interacumuladorSerpentin.Q_int_dep-(interacumuladorSerpentin.flowPort_a_int.H_flow
        +interacumuladorSerpentin.flowPort_b_int.H_flow);
      */
      der(interacumuladorSerpentin.T_int) :=  -(interacumuladorSerpentin.Q_int_dep
        -(interacumuladorSerpentin.flowPort_a_int.H_flow+interacumuladorSerpentin.flowPort_b_int.H_flow))
        /(interacumuladorSerpentin.esp.V_int*interacumuladorSerpentin.medium_int.rho
        *interacumuladorSerpentin.medium_int.cp);

    // Torn part
  // End of linear system of equations
  prescribedAmbient.T := ramp.offset+(if time < ramp.startTime then 0 else (if 
    time < ramp.startTime+ramp.duration then (time-ramp.startTime)*ramp.height/
    ramp.duration else ramp.height));
  prescribedAmbient.h := prescribedAmbient.medium.cp*prescribedAmbient.T;
  prescribedVolumeFlow1.flowPort_a.H_flow := (if semiLinearCondition(noEvent(
    interacumuladorSerpentin.flowPort_a_int.m_flow >= 0)) then prescribedAmbient.h
    *interacumuladorSerpentin.flowPort_a_int.m_flow else prescribedVolumeFlow1.h
    *interacumuladorSerpentin.flowPort_a_int.m_flow);

  // Linear system of equations
    // Symbolic solution
      /*  Original equation
      (-0.1)*prescribedVolumeFlow1.medium.cv*der(prescribedVolumeFlow1.T) = 
        interacumuladorSerpentin.flowPort_a_int.H_flow-prescribedVolumeFlow1.flowPort_a.H_flow;
      */
      der(prescribedVolumeFlow1.T) := (interacumuladorSerpentin.flowPort_a_int.H_flow
        -prescribedVolumeFlow1.flowPort_a.H_flow)/((-0.1)*prescribedVolumeFlow1.medium.cv);

    // Torn part
  // End of linear system of equations

// -----------------------------------------------------------------------------

// Accepted Section
  when pre(trapezoid.counter2) <> 0 and sample(trapezoid.startTime, 
    trapezoid.period) then
    trapezoid.counter := pre(trapezoid.counter)-(if pre(trapezoid.counter) > 0
     then 1 else 0);
  end when;
  when pre(trapezoid1.counter2) <> 0 and sample(trapezoid1.startTime, 
    trapezoid1.period) then
    trapezoid1.counter := pre(trapezoid1.counter)-(if pre(trapezoid1.counter) > 0
     then 1 else 0);
  end when;

// -----------------------------------------------------------------------------

// Conditionally Accepted Section
  prescribedVolumeFlow1.flowPort_a.h := (if semiLinearCondition(noEvent(
    interacumuladorSerpentin.flowPort_a_int.m_flow > 0)) then prescribedAmbient.h
     else prescribedVolumeFlow1.h);
  prescribedVolumeFlow.flowPort_a.h := (if semiLinearCondition(noEvent(
    interacumuladorSerpentin.flowPort_a_dep.m_flow > 0)) then ambient.h else 
    prescribedVolumeFlow.h);
  ambient.T_port := prescribedVolumeFlow.flowPort_a.h/ambient.medium.cp;

  // Linear system of equations
    // Symbolic solution
      /*  Original equation
       -(if semiLinearCondition(noEvent( -interacumuladorSerpentin.flowPort_a_dep.m_flow
         >= 0)) then 0 else  -interacumuladorSerpentin.flowPort_a_dep.m_flow)*
        ambient1.flowPort.h = (if semiLinearCondition(noEvent( -interacumuladorSerpentin.flowPort_a_dep.m_flow
         >= 0)) then  -ambient1.h*interacumuladorSerpentin.flowPort_a_dep.m_flow
         else 0)-interacumuladorSerpentin.flowPort_b_dep.H_flow;
      */
      ambient1.flowPort.h :=  -((if semiLinearCondition(noEvent( -
        interacumuladorSerpentin.flowPort_a_dep.m_flow >= 0)) then  -ambient1.h*
        interacumuladorSerpentin.flowPort_a_dep.m_flow else 0)-interacumuladorSerpentin.flowPort_b_dep.H_flow)
        /(if semiLinearCondition(noEvent( -interacumuladorSerpentin.flowPort_a_dep.m_flow
         >= 0)) then 0 else  -interacumuladorSerpentin.flowPort_a_dep.m_flow);

    // Torn part
  // End of linear system of equations
  ambient1.T_port := ambient1.flowPort.h/ambient1.medium.cp;
  prescribedVolumeFlow.flowPort_b.p := ambient1.p_Ambient-interacumuladorSerpentin.esp.dp_dep_nom
    *interacumuladorSerpentin.flowPort_a_dep.m_flow^2/interacumuladorSerpentin.esp.m_flow_dep_nom
    ^2;
  prescribedVolumeFlow.dp := ambient.p_Ambient-prescribedVolumeFlow.flowPort_b.p;
  prescribedVolumeFlow.T_a := prescribedVolumeFlow.flowPort_a.h/prescribedVolumeFlow.medium.cp;
  prescribedVolumeFlow.T_b := prescribedVolumeFlow.flowPort_b.h/prescribedVolumeFlow.medium.cp;
  prescribedVolumeFlow.dT := (if noEvent(prescribedVolumeFlow.V_flow >= 0) then 
    prescribedVolumeFlow.T-prescribedVolumeFlow.T_a else prescribedVolumeFlow.T_b
    -prescribedVolumeFlow.T);

  // Linear system of equations
    // Symbolic solution
      /*  Original equation
       -(if semiLinearCondition(noEvent( -interacumuladorSerpentin.flowPort_a_int.m_flow
         >= 0)) then 0 else  -interacumuladorSerpentin.flowPort_a_int.m_flow)*
        ambient3.flowPort.h = (if semiLinearCondition(noEvent( -interacumuladorSerpentin.flowPort_a_int.m_flow
         >= 0)) then  -ambient3.h*interacumuladorSerpentin.flowPort_a_int.m_flow
         else 0)-interacumuladorSerpentin.flowPort_b_int.H_flow;
      */
      ambient3.flowPort.h :=  -((if semiLinearCondition(noEvent( -
        interacumuladorSerpentin.flowPort_a_int.m_flow >= 0)) then  -ambient3.h*
        interacumuladorSerpentin.flowPort_a_int.m_flow else 0)-interacumuladorSerpentin.flowPort_b_int.H_flow)
        /(if semiLinearCondition(noEvent( -interacumuladorSerpentin.flowPort_a_int.m_flow
         >= 0)) then 0 else  -interacumuladorSerpentin.flowPort_a_int.m_flow);

    // Torn part
  // End of linear system of equations
  ambient3.T_port := ambient3.flowPort.h/ambient3.medium.cp;
  prescribedAmbient.T_port := prescribedVolumeFlow1.flowPort_a.h/
    prescribedAmbient.medium.cp;
  prescribedVolumeFlow1.flowPort_b.p := ambient3.p_Ambient-interacumuladorSerpentin.esp.dp_dep_nom
    *interacumuladorSerpentin.flowPort_a_int.m_flow^2/interacumuladorSerpentin.esp.m_flow_dep_nom
    ^2;
  prescribedVolumeFlow1.dp := const.k-prescribedVolumeFlow1.flowPort_b.p;
  prescribedVolumeFlow1.T_a := prescribedVolumeFlow1.flowPort_a.h/
    prescribedVolumeFlow1.medium.cp;
  prescribedVolumeFlow1.T_b := prescribedVolumeFlow1.flowPort_b.h/
    prescribedVolumeFlow1.medium.cp;
  prescribedVolumeFlow1.dT := (if noEvent(prescribedVolumeFlow1.V_flow >= 0)
     then prescribedVolumeFlow1.T-prescribedVolumeFlow1.T_a else 
    prescribedVolumeFlow1.T_b-prescribedVolumeFlow1.T);
  interacumuladorSerpentin.H_dep := interacumuladorSerpentin.esp.V_dep*
    interacumuladorSerpentin.medium_dep.rho*interacumuladorSerpentin.medium_dep.cp
    *interacumuladorSerpentin.T_dep;
  interacumuladorSerpentin.H_int := interacumuladorSerpentin.esp.V_int*
    interacumuladorSerpentin.medium_int.rho*interacumuladorSerpentin.medium_int.cp
    *interacumuladorSerpentin.T_int;

// -----------------------------------------------------------------------------

// Eliminated alias variables
  // To have eliminated alias variables listed, set
  //   Advanced.OutputModelicaCodeWithAliasVariables = true
  // before translation. May give much output.
